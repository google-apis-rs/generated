use clap::{App, AppSettings, Arg, SubCommand};
use default_boxed::DefaultBoxed;

#[derive(DefaultBoxed)]
struct Outer<'a, 'b> {
    inner: HeapApp<'a, 'b>,
}

struct HeapApp<'a, 'b> {
    app: App<'a, 'b>,
}

impl<'a, 'b> Default for HeapApp<'a, 'b> {
    fn default() -> Self {
        let mut app = App::new("identitytoolkit1")
            .setting(clap::AppSettings::ColoredHelp)
            .author("Sebastian Thiel <byronimo@gmail.com>")
            .version("0.1.0-20200503")
            .about("The Google Identity Toolkit API lets you use open standards to verify a\n    user\'s identity.")
            .after_help("All documentation details can be found at <TODO figure out URL>")
            .arg(Arg::with_name("scope")
                .long("scope")
                .help("Specify the authentication method should be executed in. Each scope requires the user to grant this application permission to use it. If unset, it defaults to the shortest scope url for a particular method.")
                .multiple(true)
                .takes_value(true))
            .arg(Arg::with_name("folder")
                .long("config-dir")
                .help("A directory into which we will store our persistent data. Defaults to a user-writable directory that we will create during the first invocation." )
                .multiple(false)
                .takes_value(true))
            .arg(Arg::with_name("debug")
                .long("debug")
                .help("Provide more output to aid with debugging")
                .multiple(false)
                .takes_value(false));
        let mut accounts0 = SubCommand::with_name("accounts")
                        .setting(AppSettings::ColoredHelp)
                        .about("methods: create_auth_uri, delete, issue_saml_response, lookup, reset_password, send_oob_code, send_verification_code, sign_in_with_custom_token, sign_in_with_email_link, sign_in_with_game_center, sign_in_with_idp, sign_in_with_password, sign_in_with_phone_number, sign_up, update and verify_ios_client");
        {
            let mcmd = SubCommand::with_name("create_auth_uri").about("If an email identifier is specified, checks and returns if any user account\nis registered with the email. If there is a registered account, fetches all\nproviders associated with the account\'s email.\n\nIf the provider ID of an Identity Provider (IdP) is specified, creates an\nauthorization URI for the IdP. The user can be directed to this URI to sign\nin with the IdP.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("delete").about("Deletes a user\'s account.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("issue_saml_response").about("Experimental");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("lookup").about("Gets account information for all matched accounts. For an end user request,\nretrieves the account of the end user. For an admin request with Google\nOAuth 2.0 credential, retrieves one or multiple account(s) with matching\ncriteria.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("reset_password").about("Resets the password of an account either using an out-of-band code\ngenerated by sendOobCode or by specifying the\nemail and password of the account to be modified. Can also check the\npurpose of an out-of-band code without consuming it.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("send_oob_code").about("Sends an out-of-band confirmation code for an account. Requests from a\nauthenticated request can optionally return a link including the OOB code\ninstead of sending it.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("send_verification_code").about("Sends a SMS verification code for phone number sign-in.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_in_with_custom_token").about("Signs in or signs up a user by exchanging a custom Auth token. Upon a\nsuccessful sign-in or sign-up, a new Identity Platform ID token and refresh\ntoken are issued for the user.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_in_with_email_link").about("Signs in or signs up a user with a out-of-band code from an email link. If\na user does not exist with the given email address, a user record will be\ncreated. If the sign-in succeeds, an Identity Platform ID and refresh token\nare issued for the authenticated user.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_in_with_game_center").about("Signs in or signs up a user with iOS Game Center credentials. If the\nsign-in succeeds, a new Identity Platform ID token and refresh token are\nissued for the authenticated user. The bundle ID is required in the request\nheader as `x-ios-bundle-identifier`.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_in_with_idp").about("Signs in or signs up a user using credentials from an Identity Provider\n(IdP). This is done by manually providing an IdP credential, or by\nproviding the authorization response obtained via the authorization\nrequest from CreateAuthUri. If the sign-in succeeds, a new Identity\nPlatform ID token and refresh token are issued for the authenticated user.\n\nA new Identity Platform user account will be created if the user has not\npreviously signed in to the IdP with the same account. In addition, when\nthe \"One account per email address\" setting is enabled, there should not\nbe an existing Identity Platform user account with the same email address\nfor a new user account to be created.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_in_with_password").about("Signs in a user with email and password. If the sign-in succeeds, a new\nIdentity Platform ID token and refresh token are issued for the\nauthenticated user.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_in_with_phone_number").about("Completes a phone number authentication attempt. If a user already\nexists with the given phone number, an ID token is minted for that user.\nOtherwise, a new user is created and associated with the phone number.\nThis method may also be used to link a phone number to an existing user.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("sign_up").about("Signs up a new email and password user or anonymous user, or upgrades an\nanonymous user to email and password. For an admin request with a Google\nOAuth 2.0 credential with the proper\n[permissions](https://cloud.google.com/identity-platform/docs/access-control),\ncreates a new anonymous, email and password, or phone number user.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("update").about("Updates account-related information for the specified user by setting\nspecific fields or applying action codes. Requests from administrators\nand end users are supported.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("verify_ios_client").about("Verifies an iOS client is a real iOS device. If the request is valid, a\nreciept will be sent in the response and a secret will be sent via\nApple Push Notification Service. The client should send both of them back\nto certain Identity Platform APIs in a later call (for example,\n/accounts:sendVerificationCode), in order to verify the client. The bundle\nID is required in the request header as `x-ios-bundle-identifier`.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            accounts0 = accounts0.subcommand(mcmd);
        }
        let mut projects0 = SubCommand::with_name("projects")
            .setting(AppSettings::ColoredHelp)
            .about("methods: accounts_method, create_session_cookie and query_accounts");
        {
            let mcmd = SubCommand::with_name("accounts_method").about("Signs up a new email and password user or anonymous user, or upgrades an\nanonymous user to email and password. For an admin request with a Google\nOAuth 2.0 credential with the proper\n[permissions](https://cloud.google.com/identity-platform/docs/access-control),\ncreates a new anonymous, email and password, or phone number user.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            projects0 = projects0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("create_session_cookie").about("Creates a session cookie for the given Identity Platform ID token. The\nsession cookie is used by the client to preserve the user\'s login state.");
            projects0 = projects0.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("query_accounts").about("Looks up user accounts within a project or a tenant based on conditions\nin the request.");
            projects0 = projects0.subcommand(mcmd);
        }
        let mut v_10 = SubCommand::with_name("v_1")
                        .setting(AppSettings::ColoredHelp)
                        .about("methods: get_projects, get_public_keys, get_recaptcha_params and get_session_cookie_public_keys");
        {
            let mcmd = SubCommand::with_name("get_projects").about("Gets a project\'s public Identity Toolkit configuration.\n(Legacy) This method also supports authenticated calls from a developer to\nretrieve non-public configuration.");
            v_10 = v_10.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("get_public_keys").about("Retrieves public keys of the legacy Identity Toolkit token signer to\nenable third parties to verify the legacy ID token. For now the X509 pem\ncert is the only format supported.");
            v_10 = v_10.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("get_recaptcha_params")
                .about("Gets parameters needed for generating a reCAPTCHA challenge.");
            v_10 = v_10.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("get_session_cookie_public_keys").about("Retrieves the set of public keys of the session cookie JSON Web Token (JWT)\nsigner that can be used to validate the session cookie created through\ncreateSessionCookie.");
            v_10 = v_10.subcommand(mcmd);
        }
        let mut accounts1 = SubCommand::with_name("accounts")
                        .setting(AppSettings::ColoredHelp)
                        .about("methods: batch_create, batch_delete, batch_get, delete, lookup, query, send_oob_code and update");
        {
            let mcmd = SubCommand::with_name("batch_create").about("Uploads multiple accounts into the Google Cloud project. If there is a\nproblem uploading one or more of the accounts, the rest will be uploaded,\nand a list of the errors will be returned. To use this method requires a\nGoogle OAuth 2.0 credential with proper\n[permissions](https://cloud.google.com/identity-platform/docs/access-control).");
            accounts1 = accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("batch_delete").about("Batch deletes multiple accounts. For accounts that fail to be deleted,\nerror info is contained in the response. The method ignores accounts that\ndo not exist or are duplicated in the request.\n\nThis method requires a Google OAuth 2.0 credential with proper permissions.\n(https://cloud.google.com/identity-platform/docs/access-control)");
            accounts1 = accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("batch_get").about("Download account information for all accounts on the project in a paginated\nmanner. To use this method requires a Google OAuth 2.0 credential with\nproper\n[permissions](https://cloud.google.com/identity-platform/docs/access-control)..\nFurthermore, additional permissions are needed to get password hash,\npassword salt, and password version from accounts; otherwise these fields\nare redacted.");
            accounts1 = accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("delete").about("Deletes a user\'s account.");
            accounts1 = accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("lookup").about("Gets account information for all matched accounts. For an end user request,\nretrieves the account of the end user. For an admin request with Google\nOAuth 2.0 credential, retrieves one or multiple account(s) with matching\ncriteria.");
            accounts1 = accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("query").about("Looks up user accounts within a project or a tenant based on conditions\nin the request.");
            accounts1 = accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("send_oob_code").about("Sends an out-of-band confirmation code for an account. Requests from a\nauthenticated request can optionally return a link including the OOB code\ninstead of sending it.");
            accounts1 = accounts1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("update").about("Updates account-related information for the specified user by setting\nspecific fields or applying action codes. Requests from administrators\nand end users are supported.");
            accounts1 = accounts1.subcommand(mcmd);
        }
        let mut tenants1 = SubCommand::with_name("tenants")
            .setting(AppSettings::ColoredHelp)
            .about("methods: accounts_method and create_session_cookie");
        {
            let mcmd = SubCommand::with_name("accounts_method").about("Signs up a new email and password user or anonymous user, or upgrades an\nanonymous user to email and password. For an admin request with a Google\nOAuth 2.0 credential with the proper\n[permissions](https://cloud.google.com/identity-platform/docs/access-control),\ncreates a new anonymous, email and password, or phone number user.\n\nAn [API key](https://cloud.google.com/docs/authentication/api-keys) is\nrequired in the request in order to identify the Google Cloud project.");
            tenants1 = tenants1.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("create_session_cookie").about("Creates a session cookie for the given Identity Platform ID token. The\nsession cookie is used by the client to preserve the user\'s login state.");
            tenants1 = tenants1.subcommand(mcmd);
        }
        let mut accounts2 = SubCommand::with_name("accounts")
                        .setting(AppSettings::ColoredHelp)
                        .about("methods: batch_create, batch_delete, batch_get, delete, lookup, query, send_oob_code and update");
        {
            let mcmd = SubCommand::with_name("batch_create").about("Uploads multiple accounts into the Google Cloud project. If there is a\nproblem uploading one or more of the accounts, the rest will be uploaded,\nand a list of the errors will be returned. To use this method requires a\nGoogle OAuth 2.0 credential with proper\n[permissions](https://cloud.google.com/identity-platform/docs/access-control).");
            accounts2 = accounts2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("batch_delete").about("Batch deletes multiple accounts. For accounts that fail to be deleted,\nerror info is contained in the response. The method ignores accounts that\ndo not exist or are duplicated in the request.\n\nThis method requires a Google OAuth 2.0 credential with proper permissions.\n(https://cloud.google.com/identity-platform/docs/access-control)");
            accounts2 = accounts2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("batch_get").about("Download account information for all accounts on the project in a paginated\nmanner. To use this method requires a Google OAuth 2.0 credential with\nproper\n[permissions](https://cloud.google.com/identity-platform/docs/access-control)..\nFurthermore, additional permissions are needed to get password hash,\npassword salt, and password version from accounts; otherwise these fields\nare redacted.");
            accounts2 = accounts2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("delete").about("Deletes a user\'s account.");
            accounts2 = accounts2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("lookup").about("Gets account information for all matched accounts. For an end user request,\nretrieves the account of the end user. For an admin request with Google\nOAuth 2.0 credential, retrieves one or multiple account(s) with matching\ncriteria.");
            accounts2 = accounts2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("query").about("Looks up user accounts within a project or a tenant based on conditions\nin the request.");
            accounts2 = accounts2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("send_oob_code").about("Sends an out-of-band confirmation code for an account. Requests from a\nauthenticated request can optionally return a link including the OOB code\ninstead of sending it.");
            accounts2 = accounts2.subcommand(mcmd);
        }
        {
            let mcmd = SubCommand::with_name("update").about("Updates account-related information for the specified user by setting\nspecific fields or applying action codes. Requests from administrators\nand end users are supported.");
            accounts2 = accounts2.subcommand(mcmd);
        }
        tenants1 = tenants1.subcommand(accounts2);
        projects0 = projects0.subcommand(tenants1);
        projects0 = projects0.subcommand(accounts1);
        app = app.subcommand(v_10);
        app = app.subcommand(projects0);
        app = app.subcommand(accounts0);

        Self { app }
    }
}
use google_identitytoolkit1 as api;

fn main() {
    // TODO: set homedir afterwards, once the address is unmovable, or use Pin for the very first time
    // to allow a self-referential structure :D!
    let _home_dir = dirs::config_dir()
        .expect("configuration directory can be obtained")
        .join("google-service-cli");
    let outer = Outer::default_boxed();
    let app = outer.inner.app;
    let _matches = app.get_matches();
}
